# Developed by the Decision Analysis in R for Technologies in Health (DARTH) group
# Fernando Alarid-Escudero, PhD (1) 
# Eva A. Enns, MS, PhD (2)	
# M.G. Myriam Hunink, MD, PhD (3,4)
# Hawre J. Jalal, MD, PhD (5) 
# Eline M. Krijkamp, MSc (3)
# Petros Pechlivanoglou, PhD (6) 

# In collaboration of: 		
# 1 Center for Research and Teaching in Economics (CIDE), Drug Policy Program, Mexico
# 2 University of Minnesota School of Public Health, Minneapolis, MN, USA
# 3 Erasmus MC, Rotterdam, The Netherlands
# 4 Harvard T.H. Chan School of Public Health, Boston, USA
# 5 University of Pittsburgh Graduate School of Public Health, Pittsburgh, PA, USA
# 6 The Hospital for Sick Children, Toronto and University of Toronto, Toronto ON, Canada


# used for sensitivity analysis


# plot health state trace
plot_m_TR <- function(m_M, title = "Health state trace" ) {
  # plot the distribution of the Pop across health states over time (trace)
  # count the number of individuals in each health state at each cycle
  m_TR <- t(apply(m_M, 2, function(x) table(factor(x, levels = v_n, ordered = TRUE)))) 
  m_TR <- m_TR / n_i                                       # calculate the proportion of individuals 
  colnames(m_TR) <- v_n                                    # name the rows of the matrix
  rownames(m_TR) <- paste("Cycle", 0:n_t, sep = " ")       # name the columns of the matrix
  # Plot trace of first health state
  matplot(m_TR, type = "l", main = title, col= 1:n_states,
          ylim = c(0, 1), ylab = "Proportion of cohort", xlab = "Cycle")
  legend("topright", v_n, col = 1:n_states,    # add a legend to current plot
         lty = rep(1, 3), bty = "n", cex = 0.65)
  
}

#### Formatting functions ####
# Run them all before continuing!
# Function for number of axis ticks in ggplot2 graphs
number_ticks <- function(n) {function(limits) pretty(limits, n)} 


#-----------------------------------------------------------------------------------------------#
#### R function to extract the parameters of a beta distribution from mean and st. deviation ####
#-----------------------------------------------------------------------------------------------#
#' @param m mean 
#' @param s standard deviation
#' 
betaPar <- function(m, s) {
  a <- m * ((m * (1 - m) / s ^ 2) - 1)
  b <- (1 - m) * ((m * (1 - m) / s ^ 2) - 1)
  list(a = a, b = b)
}

beta_params <- function(mean, sigma) {
  alpha <- ((1 - mean) / sigma ^ 2 - 1 / mean) * mean ^ 2
  beta  <- alpha * (1 / mean - 1)
  params <- list(alpha = alpha, beta = beta)
  return(params)
}


#-------------------------------------------------------------------------------------------------#
#### R function to extract the parameters of a gamma distribution from mean and st. deviation  ####
#-------------------------------------------------------------------------------------------------#
#' @param m mean 
#' @param s standard deviation
#' 
gammaPar <- function(m, s) {   
  # m: mean  
  # s: standard deviation 
  shape <- m ^ 2 / s ^ 2
  scale <- s ^ 2 / m
  list(shape = shape, scale = scale)
}


#-----------------------------------------------------------------------------------------------#
#### R function to plot Markov Trace ####
#-----------------------------------------------------------------------------------------------#
PlotTrace <- function(trace, xlab, title, txtsize = 12) {
  # Plots the Markov trace
  # Args:
  #  trace:   Markov trace generated by `CalculateMarkovTrace` function of Micro trace generated by 'CalculateMicroTrace' 
  #  xlab:    x-axis label (e.g. "years", "days" etc.)
  #  title:   Title of the plot, (e.g. "Markov Trace" or "Microsimulation Trace")
  #  txtsize: Text size for plot, default = 12
  #
  # Return
  #  plot_trace: ggplot of Markov trace
  require(reshape2)
  require(ggplot2)
  
  trace <- data.frame(time = seq(1, (nrow(trace))), trace)
  trace <- melt(trace, id.vars = "time")
  plot_trace <- ggplot(trace, aes(x = time, y = value, colour = variable)) +
    geom_line() +
    scale_colour_hue("States", l = 50) +
    ggtitle(title) +
    xlab(xlab) +
    ylab("Proportion") +
    theme_bw() +
    theme(title = element_text(face = "bold", size = 14),
          axis.title.x = element_text(face = "bold", size = txtsize),
          axis.title.y = element_text(face = "bold", size = txtsize),
          axis.text.y  = element_text(size = txtsize),
          axis.text.x  = element_text(size = txtsize))
  
  return(plot_trace)
}

#-----------------------------------------------------------------------------------------------#
#### R function to plot Markov Trace with set limits x/y axis  ####
#-----------------------------------------------------------------------------------------------#
PlotTrace2 <- function(trace, xlab, title, txtsize = 12) {
  # Plots the Markov trace
  # Args:
  #  trace:   Markov trace generated by `CalculateMarkovTrace` function of Micro trace generated by 'CalculateMicroTrace' 
  #  xlab:    x-axis label (e.g. "years", "days" etc.)
  #  title:   Title of the plot, (e.g. "Markov Trace" or "Microsimulation Trace")
  #  txtsize: Text size for plot, default = 12
  #
  # Return
  #  plot_trace: ggplot of Markov trace
  require(reshape2)
  require(ggplot2)
  
  trace <- data.frame(time = seq(1, (nrow(trace))), trace)
  trace <- melt(trace, id.vars = "time")
  plot_trace <- ggplot(trace, aes(x = time, y = value, group = variable)) +
    geom_line(aes(linetype = variable, color = variable)) +
    scale_colour_hue("States", l = 50) +
    scale_linetype_discrete("States")+
    scale_y_continuous(limits=c(0,1)) +
    ggtitle(title) +
    xlab(xlab) +
    ylab("Proportion") +
    theme_bw() +
    theme(title = element_text(face = "bold", size = 14),
          axis.title.x = element_text(face = "bold", size = txtsize),
          axis.title.y = element_text(face = "bold", size = txtsize),
          axis.text.y  = element_text(size = txtsize),
          axis.text.x  = element_text(size = txtsize))
  
  return(plot_trace)
}


#-----------------------------------------------------------------------------------------------#
#### R function to create distribution  ####
#-----------------------------------------------------------------------------------------------#

# Creating beta distribution function
beta_mom <- function(mean, var){
  # Arguments
  # mean: mean of the probability
  # var: variance of the probability
  # Returns
  # beta distribution for the probability
  term <- mean * (1 - mean) / var - 1
  alpha <- mean * term
  beta <- (1 - mean) * term
  if (var >= mean * (1 - mean)) stop("var must be less than mean * (1 - mean)")
  return(list(alpha = alpha, beta = beta))
}

beta_mom(0.8, 0.1)

# Creating a lognormal distributions
lnorm_mom <- function(mean, sd){
  # Arguments
  # mean : mean of the relative risk (in our case)
  # sd : standard deviation of the relative risk
  # Returns
  # lognormal distribution for the probability
  if (mean > 0){
    sigma2 <- log((sd ^ 2 + mean ^ 2) /mean ^ 2)
    mu <- log(mean) - 1/2 * sigma2
  } else{
    stop("Mean must be positive")
  }
  return(list(mu = mu, sigma2 = sigma2))
}


#-----------------------------------------------------------------------------------------------#
#### R function to change probabilities to rates and rates to probabilities  ####
#-----------------------------------------------------------------------------------------------#
ProbToRate <- function(p , t = 1){
  # argument
  # p: the probability of the event 
  # t:  time in which the event took place, default is same time
  # Returns:
  # r : rate
  r <- -(1/t) * log(1 - p)
  r
}


RateToProb <- function(r, t){
  p <- 1 - exp(-r * t)
  return(p)
}

#-----------------------------------------------------------------------------------------------#
#### R function to generate net monetary and net heath benefit  ####
#-----------------------------------------------------------------------------------------------#

# Function for net health benefit (NBM)
calculateNHB <- function(effectiveness, costs, WTP){
  NHB <- effectiveness - costs / WTP
  return(NHB)
}

# Function for net monetary benefit
calculateNMB <- function(effectiveness, costs, WTP) {
  NMB <- effectiveness * WTP - costs
  return(NMB)
}




#-----------------------------------------------------------------------------------------------#
#### R function that converts a VAS score into a standard gamble equivalent  ####
#-----------------------------------------------------------------------------------------------#
convertVAStoUtility <- function(vas_score, r){
  # Arguments
  ## vas_score: as reported by individual 
  ## r: conversion factor ranging between 1.6 and 2.3
  # Returns 
  ## The utility values 
  utility <- 1 - (1 - vas_score/100) ^ r
  return(utility)
}



